# **배열 & Slice**

## **배열**
배열은 연속적인 메모리 공간에 동일한 타입의 테이터를 순서적으로 저장하는 **자료구조**이다.

### **배열의 선언**
``` go
// var 변수명 [배열크기] 데이터 타입
var arr[5]int
```

배열이 선언된 후에 각 배열의 요소를 인덱스를 사용하여 읽거나 쓸 수 있다. 
``` go
var a [3]int  //정수형 3개 요소를 갖는 배열 a 선언
a[0] = 1
a[1] = 2
a[2] = 3
println(a[1]) // 2 출력
```

## **배열의 초기화**
배열을 정의할 때, 초기값을 설정할 수도 있다.  
```
[배열크기] 데이터타입 {초기값}
```

초기화 과정에서 [...]을 사용하여 배열크기를 생략하면 자동으로 요소 숫자만큼 배열 크기가 정해진다. 
``` go
var a1 = [3]int{1, 2, 3}
var a3 = [...]int{1, 2, 3} //배열크기 자동으로
```

## **다배열 배열**
Go 언어는 **다차원 배열**을 지원한다. 
``` go
var multiArray [3][4][5]int  // 정의
multiArray[0][1][2] = 10     // 사용
```

## **다차원 배열의 초기화**
``` go
var a = [2][3]int{
    {1, 2, 3},
    {4, 5, 6},  //끝에 콤마 추가
}
println(a[1][2])
```

## **Go와 C에서 배열 차이**
Go와 C에서는 배열의 작동원리에 큰 차이가 있다.
* 배열은 값이다. 한 배열을 다른 배열에 할당 할 때 모든 요소가 복사된다. 
* 특히, 함수에 배열을 패스할 때, 함수는 포인터가 아닌 복사된 배열을 받는다.
* 배열의 크기는 타입의 한 부분이다. 타입 [10]int과 [20]int는 서로 다르다.

<br>

배열을 값으로 사용하는 것이 유용할 수도 있지만 또한 **비용이 큰 연산**이 될 수도 있다.  
만약 C와 같은 실행이나 효율성을 원한다면, 아래와 같이 배열 포인터를 보낼 수도 있다.
``` go
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&array)  // 명시적인 주소 연산자(&)를 주목하라.
```

하지만 이런 스타일은 Go언어 답지 않다. 대신 `slice`를 사용하라

## **Slices**
`Slice`는 배열을 포장하므로써 **데이터 시퀀스**에 더 **일반적**이고, **강력하며**, 편리한 **인터페이스**를 제공한다.

Go에서 거의 모든 배열 프로그래밍은 단순한 배열보다는 `slice`를 사용한다.

**Slice는** 내부의 배열을 가리키는 **레퍼런스**를 쥐고 있어, 만약 다른 **slice**에 할당되어도, 둘 다 **같은 배열**을 가리킨다.  

<br>

**Go Slice** 선언은 배열을 선언하듯이
``` go 
var v[]T
```
선언하는데 배열과 달리 크기를 지정하지 않는다. 

예를 들어, 정수형 **Slice** 변수 a를 선언하기 위해서 다음과 같이 선언할 수 있다.
``` go
var a []int        //슬라이스 변수 선언
a = []int{1, 2, 3} //슬라이스에 리터럴값 지정
a[1] = 10
fmt.Println(a)     // [1, 10, 3]출력
```

### **make**
Go에서 **Slice**를 생성하는 또 다른 방법으로 Go의 내장함수 **make()** 함수를 용할 수 있다.  

**make()** 함수로 **슬라이스**를 생성하면, 개발자가 **슬라이스**의 길이와 용량을 임의로 지정할 수 있는 장점이 있다.  
* 첫번째 파라미터에서는 **타입**을 지정한다
* 두번째 파라미터에서는 **Length**를 지정한다
* 세번째는 **Capacity**를 지정한다.

이렇게 모든 요소가 **Zero value**인 슬라이스를 만들게 된다.  
* 세번째 **Capacity** 파라미터를 생략하면 **Length**와 같은 값을 가지게 된다.
* **슬라이스**의 길이, 용량은 **len()**, **cap()**함수를 사용하여 확인 가능하다.

``` go
s := make([]int, 5, 10)
println(len(s), cap(s)) // len 5, cap 10
```
**슬라이스**에 별도의 길이와 용량을 지정하지 않으면, 기본적으로 길이와 용량이 0 인 **슬라이스**를 만드는데, 이를 **Nill Slice**라 하고, **nil**과 비교하면 `참`을 리턴한다.
``` go
var s []int

if s == nil {
    println("Nil Slice")
}
println(len(s), cap(s)) // 모두 0
```

### **부분 슬라이스**
**슬라이스**에서 일부를 발췌하여 부분 슬라이스를 만들 수 있다. 부분 슬라이스는 **"슬라이스[처음인덱스:마지막인덱스]"** 형식으로 만든다.  

**슬라이스** s에 대해 인덱스 2부터 4까지의 데이타를 갖는 **슬라이스**를 만들려면, S[2:5와 같이 표현한다.
``` go
s := []int{0, 1, 2, 3, 4, 5}
s = s[2:5]  
fmt.Println(s) //2,3,4 출력
```

**슬라이스 인덱스**는 처음/마지막 둘 중 하나 혹은 둘 다를 생략할 수 도 있다.
* 처음 인덱스가 생략되면 0
* 마지막 인덱스가 생략되면 슬라이스의 마지막 인덱스
* [:]와 같이 모두 생략하면, 전체를 표현한다.
``` go
s := []int{0, 1, 2, 3, 4, 5}
s = s[2:5]     // 2, 3, 4
s = s[1:]      // 3, 4
fmt.Println(s) // 3, 4 출력
```

### **슬라이스 추가, 병합과 복사**
배열은 고정된 크기로 그 크기 이상의 데이터를 임의로 추가할 수 없지만, **슬라이스**는 자유롭게 새로운 요소를 추가할 수 있다.  

새로운 요소를 추가하기 위해서는 Go 내장함수인 **append()**를 사용한다. 

**append()** 두번째 파라미터 뒤에 계속하여 값을 추가할 수 있다.
``` go
s := []int{0, 1}
 
// 하나 확장
s = append(s, 2)       // 0, 1, 2
// 복수 요소들 확장
s = append(s, 3, 4, 5) // 0,1,2,3,4,5

fmt.Println(s)
```

내장함수 **append()**가 **슬라이스**에 데이타를 추가할 때, 내부적으로 다음과 같은 일이 일어난다.  

* **슬라이스** 용량이 아직 남아 있는 경우는 그 용량 내에서 **슬라이스** 길이를 변경하여 데이터를 추가한다.
* 용량을 초과하는 경우 현재 용량의 2배에 해당하는 새로운 **Underlying array** 을 생성하고, 기존 배열 값들을 모두 새 배열에 복제한 후 다시 **슬라이스**를 할당한다.
``` go
// len=0, cap=3 인 슬라이스
sliceA := make([]int, 0, 3)

// 계속 한 요소씩 추가
for i := 1; i <= 7; i++ {
    sliceA = append(sliceA, i)
    // 슬라이스 길이와 용량 확인
    fmt.Println(len(sliceA), cap(sliceA))
}

fmt.Println(sliceA) // 1 부터 7까지 출력
```

**출력**
```
1 3
2 3
3 3
4 6
5 6
6 6
7 12
[1 2 3 4 5 6 7]
```

**append** 함수에서 2개의 **슬라이스**를 파라미터로 가지면,  
처음 **슬라이스** 뒤에 두번째 파라미터의 **슬라이스**를 추가하게 된다.

여기서 두번째 **슬라이스** 뒤에 ... 을 붙여야 하는데 이는 **요소들의 집합**을 말한다.
``` go
sliceA := []int{1, 2, 3}
sliceB := []int{4, 5, 6}

sliceA = append(sliceA, sliceB...)
//sliceA = append(sliceA, 4, 5, 6)

fmt.Println(sliceA) // [1 2 3 4 5 6] 출력
```

**Go 슬라이스**는 내장함수 **copy()**를 사용하여 한 슬라이스를 다른 **슬라이스**로 복사할 수도 있다.  
``` go
source := []int{0, 1, 2}
target := make([]int, len(source), cap(source)*2)
copy(target, source)
fmt.Println(target)  // [0 1 2 ] 출력
println(len(target), cap(target)) // 3, 6 출력
}
```
